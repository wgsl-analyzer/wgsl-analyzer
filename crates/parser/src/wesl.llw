// Based on https://www.w3.org/TR/WGSL with some modifications.

token Enable='enable' Requires='requires' Fn='fn' Alias='alias' Struct='struct' Var='var'
      ConstAssert='const_assert' If='if' For='for' Else='else' Loop='loop' Break='break'
      While='while' Return='return' Switch='switch' Discard='discard' Continuing='continuing'
      Const='const' Case='case' Default='default' Override='override' Continue='continue'
      Let='let' True='true' False='false' Diagnostic='diagnostic';
token Semi=';' LPar='(' RPar=')' Comma=',' Eq='=' Colon=':' LBrace='{' RBrace='}' Arrow='->'
      Lt='<' Gt='>' Dot='.' At='@' LBrak='[' RBrak=']' And='&' Excl='!' Star='*' Minus='-'
      Tilde='~' Plus='+' Eq2='==' Pipe='|' And2='&&' Slash='/' Caret='^' Pipe2='||' ExclEq='!='
      Percent='%' Underscore='_' AndEq='&=' StarEq='*=' PlusEq='+=' PipeEq='|=' MinusEq='-='
      SlashEq='/=' CaretEq='^=' PercentEq='%=' Plus2='++' Minus2='--';
token Ident='<identifier>' FloatLiteral='<floating point literal>' IntLiteral='<integer literal>';
token Blankspace LineEndingComment BlockComment;

skip Blankspace LineEndingComment BlockComment;

start translation_unit;

// later validate that directives come before declarations to improve error messages
translation_unit: (global_item | ';')*;
global_item^: global_directive | global_declaration | global_assert;

global_assert: 'const_assert' expression ';'; // §10
global_directive:
  'diagnostic' diagnostic_control ';' @diagnostic_directive // §4.2
| 'enable' Ident (?1 ',' Ident)* [','] ';' @enable_directive // §4.1.1
| 'requires' Ident (?1 ',' Ident)* [','] ';' @requires_directive // §4.1.2
;
diagnostic_control: '(' severity_control_name ',' diagnostic_rule_name [','] ')';
severity_control_name: Ident;
diagnostic_rule_name: Ident ['.' Ident];

global_declaration:
  attribute* (
    function_header compound_statement @function_declaration
  | variable_declaration ';' @global_variable_declaration
  | override_declaration ';' @global_value_declaration
  )
| const_declaration ';' @global_value_declaration
| 'alias' Ident '=' type_expression ';' @type_alias_declaration
| 'struct' Ident struct_body @struct_declaration
;
function_header: 'fn' Ident '(' parameters ')' return_type;
parameters: [parameter (?1 ',' parameter)* [',']];
parameter: attribute* Ident ':' type_expression;
return_type: ['->' attribute* type_expression];
struct_body: '{' struct_member (?1 ',' struct_member)* [','] '}';
struct_member: attribute* member_ident ':' type_expression;
member_ident: Ident;

attribute:
  '@' (
    'diagnostic' diagnostic_control @diagnostic_attr
  | Ident [argument_expression_list]
    // interpolate is special
    // builtin is special
  )
;
typed_ident: Ident [':' type_expression];
full_ident^: Ident; // wesl ident

// Corresponds to type_specifier, but used in more places
type_expression: full_ident template_list;
template_list^: [#1 template_args >];
expr_template_list^: #1 [?1 template_args >template_list];
template_args^: '<' expression (?1 ',' expression)* [','] '>';

// This is pratt parser, with higher elements having a higher binding power
// Source: https://github.com/0x2a-42/lelwel/tree/main?tab=readme-ov-file#direct-left-recursion
// later check for invalid expressions, like a < b < c
expression:
  expression '[' expression ']' @indexing_expression // §8.5
| expression '.' (Ident @field_expression) // §8.5, but cannot distinguish swizzles and fields from syntax
| ('-' | '!' | '~' | '*' | '&') expression @unary_expression // §8.6, §8.7, §8.9, §8.13, §8.14
| expression ('*' | '/' | '%') expression @binary_expression // §8.7
| expression ('+' | '-') expression @binary_expression // §8.7
| ?2 expression ('<' '<' | '>' '>') expression @binary_expression // §8.9
| ?3 expression (?4 '<' | ?4 '>' | '<' '=' | '>' '=' | '==' | '!=') expression @binary_expression // §8.8
| expression '&' expression @binary_expression // §8.9
| expression '^' expression @binary_expression // §8.9
| expression '|' expression @binary_expression // §8.9
| expression '&&' expression @binary_expression // §8.6
| expression '||' expression @binary_expression // §8.6
| full_ident expr_template_list @type_expression [argument_expression_list_expr @function_call] // §8.10, §8.11
| '(' expression ')' @paren_expression // §8.4
| literal @literal
;
// §8.3
literal^:
  IntLiteral
| FloatLiteral
| 'true'
| 'false'
;
argument_expression_list: '(' [expression (?1 ',' expression)* [',']] ')' @arguments;
// extra rule for better error handling
argument_expression_list_expr: '(' [expression (?1 ',' expression)* [',']] ')' @arguments;

statement:
  attribute* (
    if_clause (?1 else_if_clause)* [else_clause] @if_statement // §9.4.1
  | 'switch' expression attribute* '{' switch_clause * '}' @switch_statement // §9.4.2
  | 'loop' attribute* '{' statement* [continuing_statement] '}' @loop_statement // §9.4.3
  | 'for' '(' [for_init] ';' [expression] ';' [for_update] ')' compound_statement @for_statement // §9.4.4
  | 'while' expression compound_statement @while_statement // §9.4.5
  // TODO: check if using & here makes it recover better https://github.com/0x2a-42/lelwel/issues/34
  | '{' statement* '}' @compound_statement // §9.1
  )
| ?2 function_call ';' @function_call_statement // §9.5
| variable_or_value ';' @variable_or_value_statement
| lhs_expression (
    '=' expression @simple_assignment_statement // §9.2.1
  | compound_assignment_operator expression @compound_assignment_statement // §9.2.3
  | '++' @increment_statement // §9.3
  | '--' @decrement_statement // §9.3
  ) ';'
| '_' '=' expression ';' @phony_assignment_statement // §9.2.2
| 'const_assert' expression ';' @assert_statement // §10.1
| 'break' ';' @break_statement // §9.4.6
| 'continue' ';' @continue_statement // §9.4.8
| ';' @empty_statement
| 'discard' ';' @discard_statement // §9.4.11
| 'return' [expression] ';' @return_statement // §9.4.10
;
continuing_statement: 'continuing' attribute* '{' (?1 statement)* [break_if_statement] '}'; // §9.4.9
break_if_statement: 'break' 'if' expression ';'; // §9.4.7
for_init:
  ?1 function_call
| variable_or_value
| variable_updating
;
for_update: ?1 function_call | variable_updating;
if_clause: 'if' expression compound_statement;
else_if_clause: 'else' 'if' expression compound_statement;
else_clause: 'else' compound_statement;
switch_clause^: case_clause | default_alone_clause;
case_clause: 'case' case_selectors [':'] compound_statement;
case_selectors: case_selector (?1 ',' case_selector)* [','];
case_selector: 'default' | expression;
default_alone_clause: 'default' [':'] compound_statement;
compound_statement: attribute* '{' & statement* '}'; // §9.1

function_call: type_expression argument_expression_list;

variable_or_value^: variable_declaration | let_declaration | const_declaration;
variable_declaration: 'var' template_list typed_ident ['=' expression];
let_declaration: 'let' typed_ident '=' expression;
const_declaration: 'const' typed_ident '=' expression;
override_declaration: 'override' typed_ident ['=' expression];

// duplicated so it can be used in `for` statement without semicolon
variable_updating:
  lhs_expression (
    '=' expression @simple_assignment_statement // §9.2.1
  | compound_assignment_operator expression @compound_assignment_statement // §9.2.3
  | '++' @increment_statement // §9.3
  | '--' @decrement_statement // §9.3
  )
| '_' '=' expression @phony_assignment_statement // §9.2.2
;
compound_assignment_operator^:
  ?1 '<' '<' '='
| ?1 '>' '>' '='
| '%='
| '&='
| '*='
| '+='
| '-='
| '/='
| '^='
| '|='
;
lhs_expression:
  lhs_expression '[' expression ']' @indexing_expression // §8.5
| lhs_expression '.' (Ident @field_expression) // §8.5
| '*' lhs_expression @unary_expression // §8.14
| '&' lhs_expression @unary_expression // §8.13
| '(' lhs_expression ')' @paren_expression // §8.4
| full_ident @ident_expression
;
