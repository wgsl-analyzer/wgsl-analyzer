#![allow(clippy::allow_attributes, reason = "clippy is weird with macros")]
#![allow(clippy::empty_structs_with_brackets, reason = "generated by macro")]

pub mod change;
pub mod input;

mod util_types;
use line_index::LineIndex;
use syntax::{Edition, Parse};
use triomphe::Arc;
pub use util_types::*;
pub use vfs::FileId;
use vfs::{AnchoredPath, VfsPath};

pub use crate::{
    // change::FileChange,
    input::{
        // BuiltDependency,
        // BuiltPackageData,
        Dependency,
        // Environment,
        // ExtraPackageData,
        LanguagePackageOrigin,
        PackageData,
        PackageDisplayName,
        PackageGraph,
        // Package,
        PackageId,
        PackageName,
        PackageOrigin,
        // PackagesIdMap,
        // PackagesMap,
        // ReleaseChannel,
        SourceRoot,
        SourceRootId,
        // TargetLayoutLoadResult,
        // UniquePackageData,
    },
};

pub trait FileLoader {
    fn resolve_path(
        &self,
        path: AnchoredPath<'_>,
    ) -> Option<FileId>;
}

#[salsa::query_group(SourceDatabaseStorage)]
pub trait SourceDatabase: FileLoader {
    #[salsa::input]
    fn file_text(
        &self,
        file_id: FileId,
    ) -> Arc<String>;

    #[salsa::input]
    fn file_path(
        &self,
        file_id: FileId,
    ) -> VfsPath;

    #[salsa::input]
    fn file_id(
        &self,
        path: VfsPath,
    ) -> FileId;

    /// Path to a file, relative to the root of its source root.
    /// Source root of the file.
    #[salsa::input]
    fn file_source_root(
        &self,
        file_id: FileId,
    ) -> SourceRootId;
    /// Contents of the source root.
    #[salsa::input]
    fn source_root(
        &self,
        id: SourceRootId,
    ) -> Arc<SourceRoot>;

    #[salsa::invoke(parse_query)]
    fn parse(
        &self,
        key: EditionedFileId,
    ) -> Parse;

    /// The package graph.
    #[salsa::input]
    fn package_graph(&self) -> Arc<PackageGraph>;

    #[salsa::invoke(source_root_packages_query)]
    fn source_root_packages(
        &self,
        key: FileId,
    ) -> Arc<[PackageId]>;

    fn line_index(
        &self,
        key: FileId,
    ) -> Arc<LineIndex>;
}

fn line_index(
    database: &dyn SourceDatabase,
    file_id: FileId,
) -> Arc<LineIndex> {
    let text = database.file_text(file_id);
    Arc::new(LineIndex::new(&text))
}

fn parse_query(
    database: &dyn SourceDatabase,
    file_id: EditionedFileId,
) -> Parse {
    let source = database.file_text(file_id.file_id);
    syntax::parse(&source, file_id.edition)
}

fn source_root_packages_query(
    database: &dyn SourceDatabase,
    file_id: FileId,
) -> Arc<[PackageId]> {
    let source_root = database.file_source_root(file_id);
    let package_graph = database.package_graph();
    package_graph
        .iter()
        .filter(|&package_id| {
            let root_file = database.file_source_root(package_graph[package_id].root_file_id);
            source_root == root_file
        })
        .collect()
}

/// Silly workaround for cyclic deps between the traits.
pub struct FileLoaderDelegate<T>(pub T);

impl<T: SourceDatabase> FileLoader for FileLoaderDelegate<&'_ T> {
    fn resolve_path(
        &self,
        path: AnchoredPath<'_>,
    ) -> Option<FileId> {
        // FIXME: this *somehow* should be platform agnostic...
        let source_root = self.0.file_source_root(path.anchor);
        let source_root = self.0.source_root(source_root);
        source_root.resolve_path(path)
    }
}

/// File together with an edition.
/// Simpler than Rust-Analyzer, because we do not macros.
/// We only track the editions at a file level, as opposed to tracking it per span.
#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct EditionedFileId {
    pub file_id: FileId,
    pub edition: Edition,
}
