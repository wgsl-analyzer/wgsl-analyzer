//! `wesl-project.json` file format.
//!
//! This format is spiritually a serialization of [`base_db::PackageGraph`]. The
//! idea here is that people who do not use `wesl-rs`, can instead teach their build
//! system to generate `wesl-project.json`, which can be ingested by
//! `wgsl-analyzer`.
//!
//! This short file is a somewhat big conceptual piece of the architecture of
//! `wgsl-analyzer`, so it's worth elaborating on the underlying ideas and
//! motivation.
//!
//! For `wgsl-analyzer` to function, it needs some information about the project.
//! Specifically, it maintains an in-memory data structure which lists all the
//! packages (compilation units) and dependencies between them. This is necessary
//! a global singleton, as we do want, eg, find usages to always search across
//! the whole project, rather than just in the "current" package.
//!
//! Normally, we get this "package graph" by calling `wesl metadata --message-format=json`
//! for each wesl workspace and merging results.
//! This works for your typical wesl project, but breaks down for large folks who
//! have a monorepo with an infinite amount of Rust code which is built with bazel or
//! some such.
//!
//! To support this use case, we need to make _something_ configurable. To avoid
//! a [midlayer mistake](https://lwn.net/Articles/336262/), we allow configuring
//! the lowest possible layer. `ProjectJson` is essentially a hook to just set
//! that global singleton in-memory data structure. It is optimized for power,
//! not for convenience (you'd be using `wesl-rs` anyway if you wanted nice things,
//! right? :)
//!
//! `wesl-project.json` also isn't necessary a file. Architecturally, we support
//! any convenient way to specify this data, which today is:
//!
//! * file on disk
//! * a field in the config (ie, you can send a JSON request with the contents
//!   of `wesl-project.json` to `wgsl-analyzer`, no need to write anything to disk)
//!
//! Another possible thing we don't do today, but which would be totally valid,
//! is to add an extension point to VS Code extension to register custom
//! project.
//!
//! In general, it is assumed that if you are going to use `wesl-project.json`,
//! you'd write a fair bit of custom code gluing your build system to ra through
//! this JSON format. This logic can take form of a VS Code extension, or a
//! proxy process which injects data into "configure" LSP request, or maybe just
//! a simple build system rule to generate the file.
//!
//! In particular, the logic for lazily loading parts of the monorepo as the
//! user explores them belongs to that extension (it's totally valid to change
//! wesl-project.json over time via configuration request!)

use base_db::{PackageDisplayName, PackageName};
use edition::Edition;
use paths::{AbsPath, AbsPathBuf, Utf8PathBuf};
use rustc_hash::{FxHashMap, FxHashSet};
use serde::{Deserialize, Serialize, de};

use crate::ManifestPath;

/// Roots and packages that compose this WESL project.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ProjectJson {
    project_root: AbsPathBuf,
    /// The path to the wesl-project.json file. May be None if this
    /// data was generated by the discoverConfig command.
    manifest: Option<ManifestPath>,
    packages: Vec<Package>,
    /// Configuration for CLI commands.
    ///
    /// Examples include a check build or a test run.
    runnables: Vec<Runnable>,
}

impl ProjectJson {
    /// Create a new ProjectJson instance.
    ///
    /// # Arguments
    ///
    /// * `manifest` - The path to the `wesl-project.json`.
    /// * `base` - The path to the workspace root (i.e. the folder containing `wesl-project.json`)
    /// * `data` - The parsed contents of `wesl-project.json`, or project json that's passed via configuration.
    pub fn new(
        manifest: Option<ManifestPath>,
        base: &AbsPath,
        data: ProjectJsonData,
    ) -> ProjectJson {
        let absolutize_on_base = |p| base.absolutize(p);
        ProjectJson {
            project_root: base.to_path_buf(),
            manifest,
            runnables: data.runnables.into_iter().map(Runnable::from).collect(),
            packages: data
                .packages
                .into_iter()
                .map(|package_data| {
                    let root_module = absolutize_on_base(package_data.root_module);
                    let is_workspace_member = package_data
                        .is_workspace_member
                        .unwrap_or_else(|| root_module.starts_with(base));
                    let (include, exclude) = match package_data.source {
                        Some(src) => {
                            let absolutize = |dirs: Vec<Utf8PathBuf>| {
                                dirs.into_iter().map(absolutize_on_base).collect::<Vec<_>>()
                            };
                            (absolutize(src.include_dirs), absolutize(src.exclude_dirs))
                        },
                        None => (
                            vec![root_module.parent().unwrap().to_path_buf()],
                            Vec::new(),
                        ),
                    };

                    Package {
                        display_name: package_data
                            .display_name
                            .as_deref()
                            .map(PackageDisplayName::from_canonical_name),
                        root_module,
                        edition: package_data.edition.into(),
                        version: package_data.version.as_ref().map(ToString::to_string),
                        deps: package_data.deps,
                        env: package_data.env,
                        is_workspace_member,
                        include,
                        exclude,
                        repository: package_data.repository,
                    }
                })
                .collect(),
        }
    }

    /// Returns the number of packages in the project.
    pub fn n_packages(&self) -> usize {
        self.packages.len()
    }

    /// Returns an iterator over the packages in the project.
    pub fn packages(&self) -> impl Iterator<Item = (PackageArrayIdx, &Package)> {
        self.packages
            .iter()
            .enumerate()
            .map(|(index, package)| (PackageArrayIdx(index), package))
    }

    /// Returns the path to the project's root folder.
    pub fn path(&self) -> &AbsPath {
        &self.project_root
    }

    pub fn package_by_root(
        &self,
        root: &AbsPath,
    ) -> Option<Package> {
        self.packages
            .iter()
            .find(|package| package.root_module == root)
            .cloned()
    }

    /// Returns the path to the project's manifest, if it exists.
    pub fn manifest(&self) -> Option<&ManifestPath> {
        self.manifest.as_ref()
    }

    /// Returns the path to the project's manifest or root folder, if no manifest exists.
    pub fn manifest_or_root(&self) -> &AbsPath {
        self.manifest
            .as_ref()
            .map_or(&self.project_root, |manifest| manifest.as_ref())
    }

    /// Returns the path to the project's root folder.
    pub fn project_root(&self) -> &AbsPath {
        &self.project_root
    }

    pub fn runnables(&self) -> &[Runnable] {
        &self.runnables
    }
}

/// A package points to the root module of a package and lists the dependencies of the package. This is
/// useful in creating the package graph.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Package {
    pub(crate) display_name: Option<PackageDisplayName>,
    pub root_module: AbsPathBuf,
    pub(crate) edition: Edition,
    pub(crate) version: Option<String>,
    pub(crate) deps: Vec<Dep>,
    pub(crate) env: FxHashMap<String, String>,
    pub(crate) is_workspace_member: bool,
    pub(crate) include: Vec<AbsPathBuf>,
    pub(crate) exclude: Vec<AbsPathBuf>,
    pub(crate) repository: Option<String>,
}

/// Additional, build-specific data about a package.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Build {
    /// The name associated with this package.
    ///
    /// This is determined by the build system that produced
    /// the `wesl-project.json` in question. For instance, if buck were used,
    /// the label might be something like `//ide/wesl/wgsl-analyzer:wgsl-analyzer`.
    ///
    /// Do not attempt to parse the contents of this string; it is a build system-specific
    /// identifier similar to [`Package::display_name`].
    pub label: String,
    /// Path corresponding to the build system-specific file defining the package.
    ///
    /// It is roughly analogous to [`ManifestPath`], but it should *not* be used with
    /// [`package::ProjectManifest::from_manifest_file`], as the build file may not be
    /// be in the `wesl-project.json`.
    pub build_file: Utf8PathBuf,
}

/// A template-like structure for describing runnables.
///
/// These are used for running and debugging binaries and tests without encoding
/// build system-specific knowledge into `wgsl-analyzer`.
///
/// # Example
///
/// Below is an example of a test runnable. `{label}` and `{test_id}`
/// are explained in [`Runnable::args`]'s documentation.
///
/// ```json
/// {
///     "program": "buck",
///     "args": [
///         "test",
///          "{label}",
///          "--",
///          "{test_id}",
///          "--print-passing-details"
///     ],
///     "cwd": "/home/user/repo-root/",
///     "kind": "testOne"
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Runnable {
    /// The program invoked by the runnable.
    ///
    /// For example, this might be `wesl`.
    pub program: String,
    /// The arguments passed to [`Runnable::program`].
    ///
    /// The args can contain two template strings: `{label}` and `{test_id}`.
    /// `wgsl-analyzer` will find and replace `{label}` with [`Build::label`] and
    /// `{test_id}` with the test name.
    pub args: Vec<String>,
    /// The current working directory of the runnable.
    pub cwd: Utf8PathBuf,
    pub kind: RunnableKind,
}

/// The kind of runnable.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RunnableKind {
    Check,

    /// Can run a binary.
    Run,

    /// Run a single test.
    TestOne,
}

#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq)]
pub struct ProjectJsonData {
    packages: Vec<PackageData>,
    #[serde(default)]
    runnables: Vec<RunnableData>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq)]
struct PackageData {
    display_name: Option<String>,
    root_module: Utf8PathBuf,
    edition: EditionData,
    #[serde(default)]
    version: Option<String>,
    deps: Vec<Dep>,
    #[serde(default)]
    cfg_groups: FxHashSet<String>,
    #[serde(default)]
    env: FxHashMap<String, String>,
    is_workspace_member: Option<bool>,
    source: Option<PackageSource>,
    #[serde(default)]
    repository: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq)]
#[serde(rename = "edition")]
enum EditionData {
    #[serde(rename = "WGSL")]
    Wgsl,
    #[serde(rename = "WESL")]
    Wesl2025Unstable,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct RunnableData {
    pub program: String,
    pub args: Vec<String>,
    pub cwd: Utf8PathBuf,
    pub kind: RunnableKindData,
}

#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum RunnableKindData {
    Check,
    Run,
    TestOne,
}

/// Identifies a package by position in the packages array.
///
/// This will differ from `Package` when multiple `ProjectJson`
/// workspaces are loaded.
#[derive(Serialize, Deserialize, Debug, Clone, Copy, Eq, PartialEq, Hash)]
#[serde(transparent)]
pub struct PackageArrayIdx(pub usize);

#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq)]
pub(crate) struct Dep {
    /// Identifies a package by position in the packages array.
    pub(crate) package: PackageArrayIdx,
    #[serde(serialize_with = "serialize_package_name")]
    #[serde(deserialize_with = "deserialize_package_name")]
    pub(crate) name: PackageName,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
struct PackageSource {
    include_dirs: Vec<Utf8PathBuf>,
    exclude_dirs: Vec<Utf8PathBuf>,
}

impl From<EditionData> for Edition {
    fn from(data: EditionData) -> Self {
        match data {
            EditionData::Wgsl => Edition::Wgsl,
            EditionData::Wesl2025Unstable => Edition::Wesl2025Unstable,
        }
    }
}

impl From<RunnableData> for Runnable {
    fn from(data: RunnableData) -> Self {
        Runnable {
            program: data.program,
            args: data.args,
            cwd: data.cwd,
            kind: data.kind.into(),
        }
    }
}

impl From<RunnableKindData> for RunnableKind {
    fn from(data: RunnableKindData) -> Self {
        match data {
            RunnableKindData::Check => RunnableKind::Check,
            RunnableKindData::Run => RunnableKind::Run,
            RunnableKindData::TestOne => RunnableKind::TestOne,
        }
    }
}

fn deserialize_package_name<'de, D>(de: D) -> std::result::Result<PackageName, D::Error>
where
    D: de::Deserializer<'de>,
{
    let name = String::deserialize(de)?;
    PackageName::new(&name)
        .map_err(|error| de::Error::custom(format!("invalid package name: {error:?}")))
}

fn serialize_package_name<S>(
    name: &PackageName,
    se: S,
) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    se.serialize_str(name.as_str())
}
